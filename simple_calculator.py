# -*- coding: utf-8 -*-
"""simple_calculator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWk858p3cq3biwVr6SJEoEVtA335OAxh

# Plan

**Instructions for your notebook tutorial**

1. Run our code cell‐by‐cell in the notebook.
2. In **Section 2**, change any hard-coded value to demonstrate “what-if” scenarios.
3. Run through Sections 3–4 to show how each intermediate result is derived.
4. Use the plots in Section 5 to visually explain tariff structures and savings.
5. Finally, use the `arbitrage_analysis` function in Section 6 to let readers experiment with different inputs.


* Note the notes section is at the end with the thought process in words.
* We still need to determine sources for the averages. This could also be a sheet where we pull the values from in the next step of the design.

## 1. Simple calculation
"""

# -------------------------------
# Section 1: Imports
# -------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# globally disable scientific notation, show two decimals
pd.set_option('display.float_format', '{:.2f}'.format)

# -------------------------------
# Section 2: Define all inputs
# -------------------------------
#–– User‐defined site/load inputs
avg_load_kW            = 250      # Average load in kW
peak_hours_per_day     = 6        # Number of peak hours to shift per day
dod                    = 0.80     # Depth of discharge (fraction)
days_per_month         = 30       # Days in billing month


#–– Tariffs (Eskom basic structure, ave values)
offpeak_tariff         = 1.18     # R/kWh
std_tariff             = 1.69     # R/kWh
peak_tariff            = 3.99     # R/kWh (average)

#–– Arbitrage charging schedule
charge_offpeak_hours   = 2.5      # Hours charged at offpeak rate
charge_std_hours       = 2.5      # Hours charged at standard rate

#–– Battery economics & usage
battery_cost_kWh       = 5000     # R per kWh installed
cycles_per_day         = 2        # Number of full charge/discharge cycles per day
days_per_year          = 365      # Days per year

# -------------------------------
# Section 3: Compute intermediate values
# -------------------------------
# 1. Tariff‐weighted charge rate
total_charge_hours = charge_offpeak_hours + charge_std_hours
charge_rate = (
    offpeak_tariff * charge_offpeak_hours
  + std_tariff     * charge_std_hours
) / total_charge_hours

# 2. Rate spread (arbitrage saving per kWh)
rate_saving = peak_tariff - charge_rate

# 3. Peak‐load energy demand (kWh/day)
peak_load_energy = avg_load_kW * peak_hours_per_day

# 4. Required battery capacity (kWh)
required_capacity_kWh = peak_load_energy / dod

# 5. Total battery system cost (R)
total_battery_cost_R = required_capacity_kWh * battery_cost_kWh

# 6. Annual kWh shifted (excluding weekends)
working_days_per_year = 365 - 104  # Exclude 104 weekend days
kWh_moved_per_year = peak_load_energy * cycles_per_day * working_days_per_year

# 7. Annual savings (R)
annual_saving_R = kWh_moved_per_year * rate_saving

# 8. Simple payback (years)
simple_payback_years = total_battery_cost_R / annual_saving_R

# -------------------------------
# Section 4: Display results
# -------------------------------
results = {
    'Average load (kW)'              : avg_load_kW,
    'Peak hours per day'             : peak_hours_per_day,
    'Depth of discharge (%)'         : dod * 100,
    'Required capacity (kWh)'        : required_capacity_kWh,
    'Battery cost per kWh (R)'       : battery_cost_kWh,
    'Total system cost (R)'          : total_battery_cost_R,
    'Charge rate (R/kWh)'            : charge_rate,
    'Peak tariff (R/kWh)'            : peak_tariff,
    'Rate spread (R/kWh)'            : rate_saving,
    'kWh shifted per year'           : kWh_moved_per_year,
    'Annual saving (R)'              : annual_saving_R,
    'Simple payback (years)'         : simple_payback_years
}

df_results = pd.DataFrame.from_dict(results, orient='index', columns=['Value'])
display(df_results)

# Show the values as numbers not e+

# -------------------------------
# Section 5: Visualizations
# -------------------------------
# 5a. Bar chart: tariffs and charge rate
plt.figure(figsize=(6,4))
plt.bar(
    ['Off-peak','Standard','Charge rate','Peak'],
    [offpeak_tariff, std_tariff, charge_rate, peak_tariff]
)
plt.ylabel('R / kWh')
plt.title('Tariffs & Weighted Charge Rate')
plt.show()

# 5b. Cumulative savings by month
months = np.arange(1, 13)
monthly_saving = annual_saving_R / 12
cumulative = monthly_saving * months

plt.figure(figsize=(6,4))
plt.plot(months, cumulative, marker='o')
plt.xlabel('Month')
plt.ylabel('Cumulative savings (R)')
plt.title('Projected Cumulative Savings')
plt.grid(True)
plt.show()

"""## 2. “What-If” function"""

# -------------------------------
# Section 6: “What-If” function
# -------------------------------
def arbitrage_analysis(
    avg_load_kW,
    peak_hours_per_day,
    dod,
    offpeak_tariff,
    std_tariff,
    peak_tariff,
    charge_offpeak_hours,
    charge_std_hours,
    battery_cost_kWh,
    cycles_per_day,
    days_per_year
):
    # Recompute all the steps above
    total_charge_hours = charge_offpeak_hours + charge_std_hours
    charge_rate = (
        offpeak_tariff * charge_offpeak_hours
      + std_tariff     * charge_std_hours
    ) / total_charge_hours
    rate_saving = peak_tariff - charge_rate
    peak_load_energy = avg_load_kW * peak_hours_per_day
    required_capacity = peak_load_energy / dod
    total_cost = required_capacity * battery_cost_kWh
    kWh_year = peak_load_energy * cycles_per_day * days_per_year
    annual_sav = kWh_year * rate_saving
    payback = total_cost / annual_sav

    return {
        'Required kWh'       : required_capacity,
        'Total cost (R)'     : total_cost,
        'Annual saving (R)'  : annual_sav,
        'Payback (yrs)'      : payback
    }

# Example call of the function
display(arbitrage_analysis(250,6,0.8,1.18,1.69,3.99,2.5,2.5,5000,2,365))

# Use our function to illustrate
display(arbitrage_analysis(
    avg_load_kW=250,
    peak_hours_per_day=6,
    dod=0.8,
    offpeak_tariff=1.18,
    std_tariff=1.69 ,
    peak_tariff=3.99,
    charge_offpeak_hours=2.5,
    charge_std_hours=2.5,
    battery_cost_kWh=5000,
    cycles_per_day=2,
    days_per_year=365))

"""## 3. Parreto Front of Simple Calculator"""

# -------------------------------
# Section 7: Pareto-front illustration
# -------------------------------
import numpy as np

# 1. Define sweep ranges
cost_range = np.linspace(3000, 7000, 9)      # R/kWh from 3 000 to 7 000
dod_range  = np.linspace(0.6, 0.9, 7)        # DoD from 60% to 90%

# 2. Build scenario table
scenarios = []
for c in cost_range:
    for d in dod_range:
        out = arbitrage_analysis(
            avg_load_kW=250,
            peak_hours_per_day=6,
            dod=d,
            offpeak_tariff=1.18,
            std_tariff=1.69,
            peak_tariff=3.99,
            charge_offpeak_hours=2.5,
            charge_std_hours=2.5,
            battery_cost_kWh=c,
            cycles_per_day=2,
            days_per_year=365
        )
        scenarios.append({
            'battery_cost_kWh': c,
            'DoD': d,
            'annual_saving':   out['Annual saving (R)'],
            'payback':         out['Payback (yrs)']
        })

df_scen = pd.DataFrame(scenarios)

# 3. Identify Pareto-efficient points
is_pareto = np.ones(len(df_scen), dtype=bool)
for i, row in df_scen.iterrows():
    # any scenario strictly better in both (higher saving & lower payback)?
    dominated = ((df_scen['annual_saving'] > row['annual_saving']) &
                 (df_scen['payback']     < row['payback']))
    if dominated.any():
        is_pareto[i] = False

df_pareto = df_scen[is_pareto]

# 4. Plot all vs. Pareto front
plt.figure(figsize=(6,4))
plt.scatter(df_scen['annual_saving'], df_scen['payback'], alpha=0.3, label='all scenarios')
plt.scatter(df_pareto['annual_saving'], df_pareto['payback'],
            color='red', label='Pareto front')
plt.xlabel('Annual saving (R)')
plt.ylabel('Payback (years)')
plt.title('Pareto-front: maximizing saving, minimizing payback')
plt.legend()
plt.grid(True)
plt.show()

plt.scatter(df_scen['payback'], df_scen['DoD'])
plt.xlabel('Payback (years)')
plt.ylabel('DoD fraction')
plt.title('Trade-off: DoD vs payback')
plt.show()

# Display the Pareto front data
display(df_pareto)

"""# Notes and considerations on phase 1 thus far

## Phase 1 notebook Plan

**1. Project goal**
Build a self-contained “peak-load shifting” calculator that:

* Takes user inputs (load, tariffs, battery specs)
* Runs the core arbitrage math (charge off-peak, discharge on-peak)
* Reports results (required capacity, cost, daily/monthly/annual savings, payback)
* Provides clear visualisations so sales and engineering can explore “what-if” scenarios

**2. Key inputs and the questions we’ll need to ask**

*From the `Simplified Dev Notes and the Excel calculator`* sheet

1. **Load profile**

   * What is the customer’s average instantaneous load (kW) over peak hours?
   * How many peak hours per day will we shift?

2. **Electricity rates**

   * What is the off-peak (or solar) tariff (R/kWh)?
   * What is the standard-time tariff (R/kWh)?
   * What is the peak-time tariff (R/kWh)?
   * If rates vary by season, what are the durations (e.g. 3 months high, 9 months low) and associated rates?

3. **Battery specs**

   * Battery capacity (kWh) or do we size it to exactly cover “peak load × peak hours”?
   * Depth-of-Discharge (%) — default 80 % but adjustable
   * Cycles per day (default 2: morning & evening)
   * Battery lifespan in cycles (brand-specific; allow selection or custom entry)
   * Cost per kWh installed (R/kWh)

4. **Operational days**

   * Days per month (typically 30)
   * Days per year for cycling = (365 – number\_of\_weekend\_days) × cycles\_per\_day

5. **Proposal tracking (stretch i.e. down the line)**

   * Client name, date and sales rep
   * Ability to save/export a PDF summary

**3. Core calculation steps**
We’ll turn those inputs into:

1. **Peak-load energy** (kWh/day) = average\_load × peak\_hours
2. **Required battery size** = peak-load\_energy ÷ (DoD / 100)
3. **Total system cost** = required\_size × cost\_per\_kWh
4. **Weighted charge cost** = \[(off-peak\_rate × charge\_hours\_off\_peak) + (std\_rate × charge\_hours\_std)] ÷ total\_charge\_hours
5. **Arbitrage margin (R/kWh)** = peak\_rate – weighted\_charge\_cost
6. **Daily savings** = peak-load\_energy × arbitrage\_margin
7. **Monthly savings** = daily\_savings × days\_per\_month
8. **Annual savings** = daily\_savings × operational\_days\_per\_year
9. **Simple payback (years)** = total\_system\_cost ÷ annual\_savings

**4. Visualisations**

* **Tariff comparison** by time-of-use and season (bar chart)
* **Savings over time** (line chart of cumulative monthly or annual savings vs time)
* **Payback sensitivity** (scatter or heatmap of payback vs DoD, battery cost or tariff spread)
* **Capacity vs cost** (if we vary peak hours or load)

## Potential considerations we are not taking into account [Dumping ideas from LLM here please paste emoji where these are valid ✅ ]

Key additional factors that would significantly enhance the battery arbitrage tool's accuracy and usefulness:

## 1. **Financial & Economic Enhancements**

**Time Value of Money:**
- **Net Present Value (NPV)** and **Internal Rate of Return (IRR)** calculations
- **Discount rate** input (cost of capital, typically 8-12% in SA)
- **Inflation escalation** for electricity tariffs (historically 8-15% annually)
- **Financing options**: cash purchase vs loan (interest rates, terms)

**Operating Costs:**
- **Annual maintenance** (1-2% of system cost)
- **Insurance costs** (0.5-1% of system value)
- **Replacement reserve** fund for inverters/BMS components

## 2. **Technical Reality Factors**

**Battery Degradation:**
- **Capacity fade** over time (2-3% annually for lithium)
- **Round-trip efficiency** losses (85-95% depending on technology)
- **Calendar aging** vs cycle aging
- **Temperature coefficient** effects on performance

**System Losses:**
- **Inverter efficiency** (94-98%)
- **DC/AC conversion** losses
- **Auxiliary power consumption** (BMS, cooling, monitoring)

## 3. **Critical South African Market Factors**

**Demand Charges (HUGE impact):**
- **Maximum demand** reduction value (often R100-200/kVA/month)
- **Notified maximum demand** optimization
- **Power factor** correction benefits

**Tariff Complexity:**
- **Seasonal variations** (high/low demand seasons)
- **Municipal vs Eskom** rate structures
- **Time-of-use** band variations by season
- **Network charges** vs energy charges

## 4. **Advanced Revenue Streams**

**Backup Power Value:**
- **Load shedding** avoidance value (productivity, equipment protection)
- **Critical load** support during outages
- **Generator fuel** cost avoidance

**Grid Services:**
- **Wheeling/virtual wheeling** revenue potential
- **Grid stabilization** services (future market)

## 5. **Risk & Sensitivity Analysis**

**Market Risks:**
- **Tariff structure changes** (what if TOU rates change?)
- **Regulatory changes** impact

**Sensitivity Analysis:**
- **Break-even analysis** for key parameters
- **Scenario planning** (optimistic/base/pessimistic)

## 6. **Operational Optimization**

**Smart Dispatch:**
- **Load forecasting** for optimal cycling
- **Dynamic pricing** response
- **Grid export** optimization (where permitted)

## 7. **Brand-Specific Factors** (per your spec)

**Battery Technology Differences:**
```python
battery_brands = {
    'SIG Energy': {'cycles': 8000, 'dod': 1.0, 'efficiency': 0.95},
    'Freedom Won': {'cycles': 6000, 'dod': 0.9, 'efficiency': 0.92},
    'Solaredge': {'cycles': 4000, 'dod': 0.9, 'efficiency': 0.94},
    'Sungrow': {'cycles': 6000, 'dod': 0.9, 'efficiency': 0.93}
}
```

## Most Impactful Additions for SA Market:

1. **Demand charge optimization** - often 50%+ of total savings
2. **Load shedding value** - quantify business continuity benefits  
3. **Proper tariff modeling** - seasonal and municipal variations
4. **NPV analysis** - proper financial evaluation
5. **Battery degradation** - realistic performance over time

Suggest starting with **demand charges**, **NPV analysis**, and **battery degradation** as these have the biggest impact on ROI calculations in the South African market.
"""



"""# Version 2 of calculations

Step-by-Step Calculation Sequence

## Basic Input Parameters

1. **Load Parameters**
   - Average load during peak hours: 250 kW
   - Peak hours per day: 6 hours
   - Depth of discharge (DoD): 80%
   - Days per month: 30 days

2. **Solar Parameters**
   - Solar capacity: 150 kW
   - Daily yield: 4.5 kWh per kWp
   - Self-consumption rate: 60%

3. **Tariff Structure**
   - Off-peak rate: R1.18/kWh
   - Standard rate: R1.69/kWh
   - Peak rate: R3.99/kWh
   - Feed-in tariff: R0.75/kWh

4. **Battery Parameters**
   - Cost: R5,000/kWh
   - Round-trip efficiency: 90%
   - Cycles per day: 2
   - Expected lifetime: 10 years

## Calculation Sequence

### 1. Calculate Weighted Charge Rate
```
Total charge hours = Off-peak hours + Standard hours
                   = 2.5 + 2.5 = 5 hours

Weighted charge rate = (Off-peak tariff × Off-peak hours + Standard tariff × Standard hours) ÷ Total hours
                     = (R1.18 × 2.5 + R1.69 × 2.5) ÷ 5
                     = (R2.95 + R4.225) ÷ 5
                     = R7.175 ÷ 5
                     = R1.435/kWh
```

### 2. Calculate Effective Rate Saving (Accounting for Efficiency)
```
Effective charge rate = Charge rate ÷ Battery efficiency
                      = R1.435 ÷ 0.9
                      = R1.594/kWh

Rate saving = Peak tariff - Effective charge rate
            = R3.99 - R1.594
            = R2.396/kWh
```

### 3. Calculate Peak Load Energy Requirements
```
Peak load energy = Average load × Peak hours
                  = 250 kW × 6 hours
                  = 1,500 kWh/day
```

### 4. Calculate Required Battery Capacity
```
Required battery capacity = Peak load energy ÷ Depth of discharge
                          = 1,500 kWh ÷ 0.8
                          = 1,875 kWh
```

### 5. Calculate Total Battery System Cost
```
Total battery cost = Required capacity × Cost per kWh
                   = 1,875 kWh × R5,000/kWh
                   = R9,375,000
```

### 6. Calculate Annual Energy Shifted by Battery
```
Daily energy shifted = Peak load energy × Cycles per day × Battery efficiency
                     = 1,500 kWh × 2 × 0.9
                     = 2,700 kWh/day

Annual energy shifted = Daily energy shifted × Days per year
                      = 2,700 kWh × 365
                      = 985,500 kWh/year
```

### 7. Calculate Solar Generation
```
Daily solar generation = Solar capacity × Solar yield
                       = 150 kW × 4.5 kWh/kWp
                       = 675 kWh/day

Annual solar generation = Daily generation × Days per year
                        = 675 kWh × 365
                        = 246,375 kWh/year
```

### 8. Calculate Solar Energy Disposition
```
Self-consumed solar = Annual generation × Self-consumption rate
                    = 246,375 kWh × 0.6
                    = 147,825 kWh/year

Exported solar = Annual generation - Self-consumed solar
               = 246,375 kWh - 147,825 kWh
               = 98,550 kWh/year
```

### 9. Calculate Solar Financial Benefits
```
Self-consumption saving = Self-consumed solar × Peak tariff
                        = 147,825 kWh × R3.99/kWh
                        = R589,822/year

Export revenue = Exported solar × Feed-in tariff
               = 98,550 kWh × R0.75/kWh
               = R73,913/year

Total solar benefit = Self-consumption saving + Export revenue
                    = R589,822 + R73,913
                    = R663,735/year
```

### 10. Calculate Battery Arbitrage Savings
```
Annual battery saving = Annual energy shifted × Rate saving
                      = 985,500 kWh × R2.396/kWh
                      = R2,359,458/year
```

### 11. Calculate Combined System Economics
```
Total annual saving = Battery saving + Solar benefit
                    = R2,359,458 + R663,735
                    = R3,023,193/year

Simple payback period = Total battery cost ÷ Total annual saving
                      = R9,375,000 ÷ R3,023,193
                      = 3.1 years
```

### 12. Calculate Levelized Cost of Storage
```
Battery lifetime cycles = Cycles per day × Days per year × Battery lifetime
                        = 2 × 365 × 10
                        = 7,300 cycles

Total lifetime energy = Peak load energy × Lifetime cycles × Battery efficiency
                      = 1,500 kWh × 7,300 × 0.9
                      = 9,855,000 kWh

Levelized cost = Total battery cost ÷ Total lifetime energy
               = R9,375,000 ÷ 9,855,000 kWh
               = R0.95/kWh
```

**Results Summary**

- **System Sizing**: 1,875 kWh battery with 150 kW solar PV
- **Battery Arbitrage**: Shifts 985,500 kWh annually, saving R2,359,458/year
- **Solar Contribution**: Generates 246,375 kWh annually, providing R663,735/year benefit
- **Combined Economics**: Total savings of R3,023,193/year with 3.1-year payback
- **Levelized Cost**: R0.95/kWh over the battery's lifetime

This calculation sequence demonstrates how the combined solar-battery system provides significant economic benefits through both peak load shifting and direct solar utilization.

## 1. Simple calculation
"""

# -------------------------------
# Section 1: Imports
# -------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings

# globally disable scientific notation, show two decimals
pd.set_option('display.float_format', '{:.2f}'.format)

# -------------------------------
# Section 2: Define all inputs
# -------------------------------
#–– User‐defined site/load inputs
avg_load_kW            = 250      # Average load in kW
peak_hours_per_day     = 6        # Number of peak hours to shift per day
dod                    = 0.80     # Depth of discharge (fraction)
days_per_month         = 30       # Days in billing month

#–– Solar inputs (new section)
solar_capacity_kW      = 150      # Solar PV system size in kW
solar_yield_kWh_kWp    = 4.5      # Average daily yield in kWh per kWp installed
solar_self_consume     = 0.60     # Fraction of solar energy directly consumed

#–– Tariffs (Eskom basic structure, average values)
offpeak_tariff         = 1.18     # R/kWh
std_tariff             = 1.69     # R/kWh
peak_tariff            = 3.99     # R/kWh (average)
feed_in_tariff         = 0.75     # R/kWh (export rate for excess solar)

#–– Arbitrage charging schedule
charge_offpeak_hours   = 2.5      # Hours charged at offpeak rate
charge_std_hours       = 2.5      # Hours charged at standard rate

#–– Battery economics & usage
battery_cost_kWh       = 5000     # R per kWh installed
battery_efficiency     = 0.90     # Round-trip efficiency (fraction)
cycles_per_day         = 2        # Number of full charge/discharge cycles per day
days_per_year          = 365      # Days per year
battery_lifetime_yrs   = 10       # Expected battery lifetime in years

# Input validation
if dod <= 0 or dod > 1:
    raise ValueError("Depth of discharge (DoD) must be between 0 and 1")

if battery_efficiency <= 0 or battery_efficiency > 1:
    raise ValueError("Battery efficiency must be between 0 and 1")

if solar_self_consume < 0 or solar_self_consume > 1:
    raise ValueError("Solar self-consumption must be between 0 and 1")

# -------------------------------
# Section 3: Compute intermediate values
# -------------------------------
# 1. Tariff‐weighted charge rate
total_charge_hours = charge_offpeak_hours + charge_std_hours
if total_charge_hours > 0:
    charge_rate = (
        offpeak_tariff * charge_offpeak_hours
      + std_tariff     * charge_std_hours
    ) / total_charge_hours
else:
    charge_rate = 0
    warnings.warn("Total charge hours is zero. Setting charge rate to 0.")

# 2. Rate spread (arbitrage saving per kWh)
rate_saving = peak_tariff - charge_rate / battery_efficiency  # Adjusted for battery efficiency

# 3. Peak‐load energy demand (kWh/day)
peak_load_energy = avg_load_kW * peak_hours_per_day

# 4. Required battery capacity (kWh)
required_capacity_kWh = peak_load_energy / dod

# 5. Total battery system cost (R)
total_battery_cost_R = required_capacity_kWh * battery_cost_kWh

# 6. Annual kWh shifted (accounting for efficiency losses)
kWh_moved_per_year = peak_load_energy * cycles_per_day * days_per_year * battery_efficiency

# 7. Solar generation calculations (new)
daily_solar_gen_kWh = solar_capacity_kW * solar_yield_kWh_kWp
annual_solar_gen_kWh = daily_solar_gen_kWh * days_per_year
solar_self_consumed_kWh = annual_solar_gen_kWh * solar_self_consume
solar_exported_kWh = annual_solar_gen_kWh - solar_self_consumed_kWh

# 8. Solar savings calculations (new)
solar_self_consume_saving = solar_self_consumed_kWh * peak_tariff  # Assume peak rate for simplicity
solar_export_revenue = solar_exported_kWh * feed_in_tariff
total_solar_benefit = solar_self_consume_saving + solar_export_revenue

# 9. Annual arbitrage savings (R)
annual_arbitrage_saving_R = kWh_moved_per_year * rate_saving

# 10. Total annual savings (combined solar + battery)
annual_saving_R = annual_arbitrage_saving_R + total_solar_benefit

# 11. Simple payback (years)
simple_payback_years = total_battery_cost_R / annual_saving_R

# 12. Levelized cost calculations
battery_cycles_lifetime = cycles_per_day * days_per_year * battery_lifetime_yrs
total_energy_lifetime_kWh = peak_load_energy * battery_cycles_lifetime * battery_efficiency
levelized_cost_R_kWh = total_battery_cost_R / total_energy_lifetime_kWh

# -------------------------------
# Section 4: Display results
# -------------------------------
results = {
    'Average load (kW)'              : avg_load_kW,
    'Peak hours per day'             : peak_hours_per_day,
    'Depth of discharge (%)'         : dod * 100,
    'Battery efficiency (%)'         : battery_efficiency * 100,
    'Required capacity (kWh)'        : required_capacity_kWh,
    'Battery cost per kWh (R)'       : battery_cost_kWh,
    'Total system cost (R)'          : total_battery_cost_R,
    'Charge rate (R/kWh)'            : charge_rate,
    'Peak tariff (R/kWh)'            : peak_tariff,
    'Rate spread (R/kWh)'            : rate_saving,
    'kWh shifted per year'           : kWh_moved_per_year,
    'Annual battery saving (R)'      : annual_arbitrage_saving_R,
    'Solar capacity (kW)'            : solar_capacity_kW,
    'Annual solar generation (kWh)'  : annual_solar_gen_kWh,
    'Solar self-consumed (kWh)'      : solar_self_consumed_kWh,
    'Solar exported (kWh)'           : solar_exported_kWh,
    'Solar benefit (R)'              : total_solar_benefit,
    'Total annual saving (R)'        : annual_saving_R,
    'Simple payback (years)'         : simple_payback_years,
    'Levelized cost (R/kWh)'         : levelized_cost_R_kWh
}

df_results = pd.DataFrame.from_dict(results, orient='index', columns=['Value'])
print("Results Summary:")
print(df_results)  # Using print instead of display for compatibility

# -------------------------------
# Section 5: Visualizations
# -------------------------------
# 5a. Bar chart: tariffs and charge rate
plt.figure(figsize=(8,5))
plt.bar(
    ['Off-peak','Standard','Charge rate','Peak','Feed-in'],
    [offpeak_tariff, std_tariff, charge_rate, peak_tariff, feed_in_tariff],
    color=['green', 'orange', 'blue', 'red', 'purple']
)
plt.ylabel('R / kWh')
plt.title('Tariffs & Weighted Charge Rate')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 5b. Cumulative savings by month (including solar)
months = np.arange(1, 13)
monthly_battery_saving = annual_arbitrage_saving_R / 12
monthly_solar_saving = total_solar_benefit / 12
monthly_total_saving = monthly_battery_saving + monthly_solar_saving

cumulative_battery = monthly_battery_saving * months
cumulative_solar = monthly_solar_saving * months
cumulative_total = monthly_total_saving * months

plt.figure(figsize=(8,5))
plt.plot(months, cumulative_battery, marker='o', label='Battery Arbitrage')
plt.plot(months, cumulative_solar, marker='s', label='Solar Benefit')
plt.plot(months, cumulative_total, marker='^', label='Total Savings', linewidth=2)
plt.xlabel('Month')
plt.ylabel('Cumulative savings (R)')
plt.title('Projected Cumulative Savings')
plt.legend()
plt.grid(True)
plt.show()

# 5c. Energy flow sankey diagram (basic version)
plt.figure(figsize=(10,6))
labels = ['Solar\nGeneration', 'Self-\nConsumption', 'Grid\nExport', 'Peak Load\nShifting', 'Total\nSavings']
values = [annual_solar_gen_kWh, solar_self_consumed_kWh, solar_exported_kWh, kWh_moved_per_year, None]
colors = ['#ffa500', '#4CAF50', '#2196F3', '#9C27B0', '#F44336']

# Simple bar chart as a substitute for Sankey diagram
plt.bar(labels[:4], values[:4], color=colors[:4])
plt.ylabel('Annual Energy (kWh)')
plt.title('System Energy Flows')
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 5d. Pie chart for savings breakdown
labels = ['Battery Arbitrage', 'Solar Self-Consumption', 'Solar Export']
savings = [annual_arbitrage_saving_R, solar_self_consume_saving, solar_export_revenue]

plt.figure(figsize=(8,5))
plt.pie(savings, labels=labels, autopct='%1.1f%%', startangle=90, colors=['#9C27B0', '#4CAF50', '#2196F3'])
plt.axis('equal')
plt.title('Annual Savings Breakdown')
plt.show()

"""## 2. "What-If" function"""

# -------------------------------
# Section 6: "What-If" function
# -------------------------------
def arbitrage_analysis(
    avg_load_kW,
    peak_hours_per_day,
    dod,
    offpeak_tariff,
    std_tariff,
    peak_tariff,
    charge_offpeak_hours,
    charge_std_hours,
    battery_cost_kWh,
    battery_efficiency=0.9,
    cycles_per_day=2,
    days_per_year=365,
    solar_capacity_kW=0,
    solar_yield_kWh_kWp=4.5,
    solar_self_consume=0.6,
    feed_in_tariff=0.75
):
    """
    Comprehensive analysis of solar + battery arbitrage economics.

    Parameters:
    -----------
    avg_load_kW : float
        Average load in kW during peak hours
    peak_hours_per_day : float
        Number of peak hours to shift per day
    dod : float
        Depth of discharge as a fraction (0-1)
    offpeak_tariff : float
        Off-peak electricity rate in R/kWh
    std_tariff : float
        Standard electricity rate in R/kWh
    peak_tariff : float
        Peak electricity rate in R/kWh
    charge_offpeak_hours : float
        Hours charged at off-peak rate
    charge_std_hours : float
        Hours charged at standard rate
    battery_cost_kWh : float
        Battery cost per kWh in R
    battery_efficiency : float
        Round-trip battery efficiency as a fraction (0-1)
    cycles_per_day : int
        Number of battery cycles per day
    days_per_year : int
        Days of operation per year
    solar_capacity_kW : float
        Solar PV system size in kW
    solar_yield_kWh_kWp : float
        Daily solar yield in kWh per kWp installed
    solar_self_consume : float
        Fraction of solar directly consumed (0-1)
    feed_in_tariff : float
        Feed-in tariff for exported solar in R/kWh

    Returns:
    --------
    dict
        Dictionary containing calculated results
    """
    # Input validation
    if dod <= 0 or dod > 1:
        raise ValueError("Depth of discharge (DoD) must be between 0 and 1")

    if battery_efficiency <= 0 or battery_efficiency > 1:
        raise ValueError("Battery efficiency must be between 0 and 1")

    if solar_self_consume < 0 or solar_self_consume > 1:
        raise ValueError("Solar self-consumption must be between 0 and 1")

    # Battery arbitrage calculations
    total_charge_hours = charge_offpeak_hours + charge_std_hours
    if total_charge_hours > 0:
        charge_rate = (
            offpeak_tariff * charge_offpeak_hours
          + std_tariff     * charge_std_hours
        ) / total_charge_hours
    else:
        charge_rate = 0
        warnings.warn("Total charge hours is zero. Setting charge rate to 0.")

    rate_saving = peak_tariff - charge_rate / battery_efficiency
    peak_load_energy = avg_load_kW * peak_hours_per_day
    required_capacity = peak_load_energy / dod
    total_cost = required_capacity * battery_cost_kWh
    kWh_year = peak_load_energy * cycles_per_day * days_per_year * battery_efficiency
    battery_annual_saving = kWh_year * rate_saving

    # Solar calculations
    daily_solar_gen = solar_capacity_kW * solar_yield_kWh_kWp
    annual_solar_gen = daily_solar_gen * days_per_year
    solar_self_consumed = annual_solar_gen * solar_self_consume
    solar_exported = annual_solar_gen - solar_self_consumed

    # Solar benefits
    solar_self_consume_saving = solar_self_consumed * peak_tariff
    solar_export_revenue = solar_exported * feed_in_tariff
    total_solar_benefit = solar_self_consume_saving + solar_export_revenue

    # Combined benefits
    total_annual_saving = battery_annual_saving + total_solar_benefit

    # Economic metrics
    if total_annual_saving > 0:
        payback = total_cost / total_annual_saving
    else:
        payback = float('inf')

    return {
        'Required_capacity_kWh'    : required_capacity,
        'Total_cost_R'             : total_cost,
        'Battery_annual_saving_R'  : battery_annual_saving,
        'Solar_annual_benefit_R'   : total_solar_benefit,
        'Total_annual_saving_R'    : total_annual_saving,
        'Payback_years'            : payback,
        'Annual_solar_gen_kWh'     : annual_solar_gen,
        'Solar_self_consumed_kWh'  : solar_self_consumed,
        'Solar_exported_kWh'       : solar_exported
    }

# Example call of the function with solar integration
result = arbitrage_analysis(
    avg_load_kW=250,
    peak_hours_per_day=6,
    dod=0.8,
    offpeak_tariff=1.18,
    std_tariff=1.69,
    peak_tariff=3.99,
    charge_offpeak_hours=2.5,
    charge_std_hours=2.5,
    battery_cost_kWh=5000,
    battery_efficiency=0.9,
    cycles_per_day=2,
    days_per_year=365,
    solar_capacity_kW=150,
    solar_yield_kWh_kWp=4.5,
    solar_self_consume=0.6,
    feed_in_tariff=0.75
)

# Convert to DataFrame for better display
df_result = pd.DataFrame.from_dict(result, orient='index', columns=['Value'])
print("What-If Analysis Results:")
print(df_result)  # Using print instead of display for compatibility

"""## 3. Pareto Front of Solar-Battery Calculator"""

# -------------------------------
# Section 7: Pareto-front illustration
# -------------------------------

# 1. Define sweep ranges
cost_range = np.linspace(3000, 7000, 9)      # R/kWh from 3,000 to 7,000
dod_range  = np.linspace(0.6, 0.9, 7)        # DoD from 60% to 90%
solar_range = np.linspace(0, 300, 7)         # Solar capacity from 0 to 300 kW

# 2. Build scenario table - now including solar
scenarios = []

# First analyze battery cost vs DoD (with fixed solar)
for c in cost_range:
    for d in dod_range:
        try:
            out = arbitrage_analysis(
                avg_load_kW=250,
                peak_hours_per_day=6,
                dod=d,
                offpeak_tariff=1.18,
                std_tariff=1.69,
                peak_tariff=3.99,
                charge_offpeak_hours=2.5,
                charge_std_hours=2.5,
                battery_cost_kWh=c,
                battery_efficiency=0.9,
                cycles_per_day=2,
                days_per_year=365,
                solar_capacity_kW=150  # Fixed solar capacity
            )
            scenarios.append({
                'battery_cost_kWh': c,
                'DoD': d,
                'solar_capacity_kW': 150,
                'annual_saving': out['Total_annual_saving_R'],
                'payback': out['Payback_years']
            })
        except Exception as e:
            print(f"Error in scenario: {e}")

# 3. Identify Pareto-efficient points
is_pareto = np.ones(len(scenarios), dtype=bool)
for i, row_i in enumerate(scenarios):
    for j, row_j in enumerate(scenarios):
        if i != j:
            # Check if scenario j dominates scenario i
            if (row_j['annual_saving'] >= row_i['annual_saving'] and
                row_j['payback'] <= row_i['payback'] and
                (row_j['annual_saving'] > row_i['annual_saving'] or
                 row_j['payback'] < row_i['payback'])):
                is_pareto[i] = False
                break

df_scen = pd.DataFrame(scenarios)
df_pareto = df_scen[is_pareto]

# 4. Plot all vs. Pareto front
plt.figure(figsize=(8,6))
plt.scatter(df_scen['annual_saving'], df_scen['payback'], alpha=0.3, label='All Scenarios')
plt.scatter(df_pareto['annual_saving'], df_pareto['payback'],
            color='red', s=100, label='Pareto Front')
plt.xlabel('Annual Saving (R)')
plt.ylabel('Payback (Years)')
plt.title('Pareto Front: Maximizing Saving, Minimizing Payback')
plt.legend()
plt.grid(True)
plt.show()

# 5. Show relationship between DoD and payback
plt.figure(figsize=(8,6))
plt.scatter(df_scen['payback'], df_scen['DoD'], c=df_scen['annual_saving'],
            cmap='viridis', alpha=0.7)
plt.colorbar(label='Annual Saving (R)')
plt.xlabel('Payback (Years)')
plt.ylabel('Depth of Discharge (DoD)')
plt.title('Trade-off: DoD vs Payback')
plt.grid(True)
plt.show()

# 6. Now analyze solar capacity impact (fixed battery parameters)
solar_scenarios = []
for s in solar_range:
    try:
        out = arbitrage_analysis(
            avg_load_kW=250,
            peak_hours_per_day=6,
            dod=0.8,  # Fixed DoD
            offpeak_tariff=1.18,
            std_tariff=1.69,
            peak_tariff=3.99,
            charge_offpeak_hours=2.5,
            charge_std_hours=2.5,
            battery_cost_kWh=5000,  # Fixed battery cost
            battery_efficiency=0.9,
            cycles_per_day=2,
            days_per_year=365,
            solar_capacity_kW=s,
            solar_yield_kWh_kWp=4.5,
            solar_self_consume=0.6,
            feed_in_tariff=0.75
        )
        solar_scenarios.append({
            'solar_capacity_kW': s,
            'battery_saving': out['Battery_annual_saving_R'],
            'solar_saving': out['Solar_annual_benefit_R'],
            'total_saving': out['Total_annual_saving_R'],
            'payback': out['Payback_years']
        })
    except Exception as e:
        print(f"Error in solar scenario: {e}")

df_solar = pd.DataFrame(solar_scenarios)

# 7. Plot impact of solar capacity
plt.figure(figsize=(8,6))
plt.plot(df_solar['solar_capacity_kW'], df_solar['battery_saving'],
         label='Battery Arbitrage Saving', marker='o')
plt.plot(df_solar['solar_capacity_kW'], df_solar['solar_saving'],
         label='Solar Benefit', marker='s')
plt.plot(df_solar['solar_capacity_kW'], df_solar['total_saving'],
         label='Total Saving', marker='^', linewidth=2)
plt.xlabel('Solar Capacity (kW)')
plt.ylabel('Annual Saving (R)')
plt.title('Impact of Solar Capacity on System Economics')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8,6))
plt.plot(df_solar['solar_capacity_kW'], df_solar['payback'], marker='o')
plt.xlabel('Solar Capacity (kW)')
plt.ylabel('Payback (Years)')
plt.title('Impact of Solar Capacity on Payback Period')
plt.grid(True)
plt.show()

# Display the Pareto front data
print("Pareto-Optimal Configurations:")
print(df_pareto[['battery_cost_kWh', 'DoD', 'solar_capacity_kW', 'annual_saving', 'payback']])

"""# Notes and Future Considerations

## Solar Integration Benefits

1. **Solar generation directly offsets consumption**: Especially valuable during peak hours when tariffs are highest
2. **Battery + Solar synergy**: Solar can charge batteries during the day, reducing grid charging needs
3. **Excess solar export**: Can generate additional revenue through feed-in tariffs
4. **Combined economics**: Often yields better payback than either technology alone

## Next Steps for Calculator Enhancement

1. **Time-based simulation**: Model hourly solar generation and load profiles
2. **Seasonal variations**: Account for winter/summer differences in solar yield
3. **Battery degradation model**: More accurate lifetime calculations
4. **Financial analysis**: Add NPV, IRR, and LCOE calculations
5. **Carbon savings calculation**: Quantify emissions reduction
6. **Weather data integration**: Use location-specific solar resources
7. **Load shifting optimization**: Determine optimal battery size based on load profile

## Data Sources for Future Integration

- **Solar yield data**: Global Horizontal Irradiance (GHI) databases for South Africa
- **Load profile templates**: Typical profiles for commercial/industrial customers
- **Tariff structures**: Updated Eskom and municipal tariff tables
- **Battery specifications**: Cycle life vs. DoD curves for different battery chemistries
"""